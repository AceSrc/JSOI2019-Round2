
\begin{frame}
\frametitle{Part 1}

给定一棵树 $T$, 要计算将这棵树分成 $j$ 条链的方案数, 是一个典型的树形 DP(树上背包), 可以在 $O(n^2)$ 内计算出来. 

注意, 每条链是有方向的, $u \to v$ 和 $v \to u$ 是不同的方案, 因为从别的树跳到 $u$ 再走到 $v$ 和从别的树跳到 $v$ 再走到 $u$ 属于不同的哈密顿回路. 
所以做背包的时候每条点数大于 $1$ 的链答案要乘以 $2$. 

还有一个点也算一条链, 不用乘 $2$. 
\end{frame}

\begin{frame}
\frametitle{Part 2}
假设没有第一个元素为第一棵树的第一条链, 最后一个元素不能来自第一棵树的限制. (等价于求解哈密顿路径个数.)

容斥部分, 最简单的想法是, 记 $g(i, j, k)$ 为考虑前 $i$ 棵树, 总共分出了 $j$ 个自由组, 非法元素的个数至少是 $k$ 的方案数. 

如何表示至少有 $k$ 个非法元素? 用类似错排问题的做法, 进行捆绑. 

比如我们现在枚举第 $x$ 棵树要分成 $y$ 条链, 我们想让这 $y$ 条链生成至少 $z$ 个非法元素, 那么我们可以把 $y$ 个数分成 $y-z$ 类自由组, 
每一类捆绑起来, 表示在排列中该类总是排在一起的. 

这和第一类斯特林数有点类似, 但和第一类斯特林数的区别在于该问题是将 $y$ 个元素分成 $y - z$ 个排列, 而不是圆排列. 

令 $S(i, j)$ 是将 $i$ 个元素分成 $j$ 个排列的方案数, 递归式是:

$S(i, j) = S(i - 1, j - 1)+(i - 1 + j)S(i - 1, j)$
\end{frame}

\begin{frame}
\frametitle{Part 2}

$g$ 最简单的方程是

$g(i, j + y - z, k + z) += g(i - 1, j, k) * f(i, y) * S(y, y - z)$

最后我们结果是 $\sum_{j} j! \times (\sum_{2 | k}f(m, j, k) - \sum_{2 | k + 1}f(m, j, k)))$.

可以看出我们没必要记录 $k$, 我们只需要记录 $k$ 的奇偶性.  

这样就得到了一个 $O(n^3)$ 的做法. 
\end{frame}

\begin{frame}
\frametitle{Part 2}


修改之后再观察下方程:
$g(i, j + y - z, (k + z)) += g(i - 1, j, k) * f(i, y) * S(y, y - z)$

我们可以将式子分成两部分, 

\end{frame}

